const express = require('express');
const router = express.Router();
const moment = require('moment');
const { v4: uuidv4 } = require('uuid');
const path = require('path');
const fs = require('fs').promises;
const PDFDocument = require('pdfkit');
const ExcelJS = require('exceljs');
const QRCode = require('qrcode');
const requireAuth = require('../middleware/requireAuth');

// // Authentication middleware
// const requireAuth = (req, res, next) => {
//     if (!req.session || !req.session.user) {
//         return res.status(401).json({ error: 'Unauthorized - Please login' });
//     }
//     next();
// };

// IMPORTANT: Move the /generated route BEFORE the /:report_id route to prevent conflicts
// Get generated reports for current user - MOVED UP
router.get('/generated', requireAuth, async (req, res) => {
    const user = req.user.username || req.user;
    console.log('Fetching generated reports for user:', user);

    try {
        const generatedReportsCollection = req.db.collection('generated_reports');
        
        // Get reports generated by current user that haven't expired
        const generatedReports = await generatedReportsCollection
            .find(
                {
                    generated_by: user,
                    expires_at: { $gte: new Date() }
                },
                { projection: { _id: 0 } }
            )
            .sort({ generated_at: -1 })
            .toArray();
        
        console.log(`Found ${generatedReports.length} generated reports for user ${user}`);
        res.json(generatedReports);
        
    } catch (error) {
        console.error('Error fetching generated reports:', error);
        res.status(500).json({ error: error.message });
    }
});

// Report generation classes
class ReportGenerator {
    constructor(db) {
        this.db = db;
        this.attendanceCollection = db.collection('attendance');
        this.memberCollection = db.collection('member');
        this.generatedReportsCollection = db.collection('generated_reports');
    }

    async generateMemberIdCards(parameters) {
        const statusFilter = parameters.status || 'Active';
        const gradeFilter = parameters.grade || 'All';
        const cardsPerPage = parseInt(parameters.cards_per_page || '10');
        const includeQrCode = parameters.include_qr_code !== false;
        const academicYear = parameters.academic_year || '2024-2025';

        // Build query
        const query = {};
        if (statusFilter !== 'All') {
            query.status = statusFilter;
        }
        if (gradeFilter !== 'All') {
            query.grade = gradeFilter;
        }

        // Get member data
        const members = await this.memberCollection
            .find(query)
            .sort({ grade: 1, name: 1 })
            .toArray();

        // Process data for ID cards
        const idCardData = [];
        for (const member of members) {
            const cardData = {
                student_id: member.student_id,
                name: member.name,
                grade: member.grade,
                status: member.status,
                parent_name: member.parent_name || '',
                contact: member.contact || '',
                academic_year: academicYear,
                include_qr_code: includeQrCode
            };
            idCardData.push(cardData);
        }

        return {
            title: `Member ID Cards - ${academicYear}`,
            data: idCardData,
            cards_per_page: cardsPerPage,
            include_qr_code: includeQrCode,
            academic_year: academicYear,
            summary: {
                total_cards: idCardData.length,
                cards_per_page: cardsPerPage,
                estimated_pages: Math.ceil(idCardData.length / cardsPerPage),
                filters: {
                    status: statusFilter,
                    grade: gradeFilter,
                    academic_year: academicYear
                }
            }
        };
    }

    async generateAttendanceSummary(parameters) {
        const startDate = moment(parameters.start_date).startOf('day').toDate();
        const endDate = moment(parameters.end_date).endOf('day').toDate();
        const gradeFilter = parameters.grade;

        let query = `
            SELECT 
                a.student_id,
                m.name,
                m.grade,
                a.timestamp
            FROM attendance a
            JOIN members m ON a.student_id = m.student_id
            WHERE a.timestamp >= $1 AND a.timestamp <= $2
        `;
        
        const queryParams = [startDate, endDate];
        
        if (gradeFilter && gradeFilter !== 'All') {
            query += ` AND m.grade = $${queryParams.length + 1}`;
            queryParams.push(gradeFilter);
        }
        
        query += ` ORDER BY a.timestamp`;
        
        const result = await this.db.query(query, queryParams);
        
        const attendanceData = result.rows.map(record => ({
            student_id: record.student_id,
            name: record.name,
            grade: record.grade,
            timestamp: record.timestamp,
            date: moment(record.timestamp).format('YYYY-MM-DD'),
            time: moment(record.timestamp).format('HH:mm:ss')
        }));

        return {
            title: `Attendance Summary (${moment(startDate).format('YYYY-MM-DD')} to ${moment(endDate).format('YYYY-MM-DD')})`,
            data: attendanceData,
            summary: {
                total_records: attendanceData.length,
                unique_students: new Set(attendanceData.map(r => r.student_id)).size,
                date_range: `${moment(startDate).format('YYYY-MM-DD')} to ${moment(endDate).format('YYYY-MM-DD')}`
            }
        };
    }

  async generateStudentRoster(parameters) {
        const statusFilter = parameters.status || 'All';
        const gradeFilter = parameters.grade || 'All';
        const includeContact = parameters.include_contact !== false;

        let query = `
            SELECT 
                student_id, name, grade, status, parent_name, contact, email
            FROM members
        `;
        
        const whereConditions = [];
        const queryParams = [];
        
        if (statusFilter !== 'All') {
            whereConditions.push(`status = $${queryParams.length + 1}`);
            queryParams.push(statusFilter);
        }
        
        if (gradeFilter !== 'All') {
            whereConditions.push(`grade = $${queryParams.length + 1}`);
            queryParams.push(gradeFilter);
        }
        
        if (whereConditions.length > 0) {
            query += ` WHERE ${whereConditions.join(' AND ')}`;
        }
        
        query += ` ORDER BY grade, name`;
        
        const result = await this.db.query(query, queryParams);
        
        const rosterData = result.rows.map(member => {
            const studentData = {
                student_id: member.student_id,
                name: member.name,
                grade: member.grade,
                status: member.status
            };

            if (includeContact) {
                studentData.parent_name = member.parent_name || '';
                studentData.contact = member.contact || '';
                studentData.email = member.email || '';
            }

            return studentData;
        });

        return {
            title: 'Student Roster Report',
            data: rosterData,
            summary: {
                total_students: rosterData.length,
                filters: {
                    status: statusFilter,
                    grade: gradeFilter,
                    include_contact: includeContact
                }
            }
        };
    }

 async generateDailyAttendance(parameters) {
        const targetDate = moment(parameters.date).format('YYYY-MM-DD');
        const startOfDay = moment(targetDate).startOf('day').toDate();
        const endOfDay = moment(targetDate).endOf('day').toDate();

        // Get attendance for the day
        const attendanceQuery = `
            SELECT 
                a.student_id,
                a.timestamp
            FROM attendance a
            WHERE a.timestamp >= $1 AND a.timestamp <= $2
            ORDER BY a.timestamp
        `;
        
        const attendanceResult = await this.db.query(attendanceQuery, [startOfDay, endOfDay]);
        
        // Get all active students
        const studentsQuery = `
            SELECT student_id, name, grade
            FROM members 
            WHERE status = 'Active'
            ORDER BY grade, name
        `;
        
        const studentsResult = await this.db.query(studentsQuery);
        
        // Create attendance lookup
        const presentStudents = {};
        attendanceResult.rows.forEach(record => {
            presentStudents[record.student_id] = record;
        });

        const dailyData = studentsResult.rows.map(student => ({
            student_id: student.student_id,
            name: student.name,
            grade: student.grade,
            status: presentStudents[student.student_id] ? 'Present' : 'Absent',
            check_in_time: presentStudents[student.student_id] ? 
                moment(presentStudents[student.student_id].timestamp).format('HH:mm:ss') : ''
        }));

        const attendanceRate = studentsResult.rows.length > 0 ?
            Math.round((attendanceResult.rows.length / studentsResult.rows.length) * 100) : 0;

        return {
            title: `Daily Attendance Report - ${targetDate}`,
            data: dailyData,
            summary: {
                date: targetDate,
                total_students: studentsResult.rows.length,
                present_count: attendanceResult.rows.length,
                absent_count: studentsResult.rows.length - attendanceResult.rows.length,
                attendance_rate: `${attendanceRate}%`
            }
        };
    }

    async generateEnrollmentStatistics(parameters) {
        const academicYear = parameters.academic_year || '2024-2025';
        
        // Get enrollment by grade
        const enrollmentByGrade = await this.memberCollection.aggregate([
            { $match: { status: { $in: ['Active', 'Inactive'] } } },
            { 
                $group: {
                    _id: '$grade',
                    total: { $sum: 1 },
                    active: { $sum: { $cond: [{ $eq: ['$status', 'Active'] }, 1, 0] } },
                    inactive: { $sum: { $cond: [{ $eq: ['$status', 'Inactive'] }, 1, 0] } }
                }
            },
            { $sort: { _id: 1 } }
        ]).toArray();

        // Get enrollment trends by month (registration dates)
        const enrollmentTrends = await this.memberCollection.aggregate([
            { $match: { created_at: { $exists: true } } },
            {
                $group: {
                    _id: {
                        year: { $year: '$created_at' },
                        month: { $month: '$created_at' }
                    },
                    count: { $sum: 1 }
                }
            },
            { $sort: { '_id.year': 1, '_id.month': 1 } },
            { $limit: 12 }
        ]).toArray();

        // Get status distribution
        const statusDistribution = await this.memberCollection.aggregate([
            {
                $group: {
                    _id: '$status',
                    count: { $sum: 1 }
                }
            }
        ]).toArray();

        // Prepare summary data
        const summaryData = [];
        
        // Add grade statistics
        enrollmentByGrade.forEach(grade => {
            summaryData.push({
                category: 'Grade',
                subcategory: grade._id,
                total: grade.total,
                active: grade.active,
                inactive: grade.inactive
            });
        });

        // Add monthly trends
        enrollmentTrends.forEach(trend => {
            summaryData.push({
                category: 'Monthly Registration',
                subcategory: `${trend._id.year}-${String(trend._id.month).padStart(2, '0')}`,
                total: trend.count,
                active: '',
                inactive: ''
            });
        });

        // Add status distribution
        statusDistribution.forEach(status => {
            summaryData.push({
                category: 'Status',
                subcategory: status._id,
                total: status.count,
                active: '',
                inactive: ''
            });
        });

        return {
            title: `Enrollment Statistics - ${academicYear}`,
            data: summaryData,
            summary: {
                academic_year: academicYear,
                total_enrolled: enrollmentByGrade.reduce((sum, grade) => sum + grade.total, 0),
                total_active: enrollmentByGrade.reduce((sum, grade) => sum + grade.active, 0),
                total_grades: enrollmentByGrade.length
            }
        };
    }
    
    async generateMemberIdCards(parameters) {
        const statusFilter = parameters.status || 'Active';
        const gradeFilter = parameters.grade || 'All';
        const cardsPerPage = parseInt(parameters.cards_per_page || '10');
        const includeQrCode = parameters.include_qr_code !== false;
        const academicYear = parameters.academic_year || '2024-2025';

        // Build query
        const query = {};
        if (statusFilter !== 'All') {
            query.status = statusFilter;
        }
        if (gradeFilter !== 'All') {
            query.grade = gradeFilter;
        }

        // Get member data
        const members = await this.memberCollection
            .find(query)
            .sort({ grade: 1, name: 1 })
            .toArray();

        // Process data for ID cards
        const idCardData = [];
        for (const member of members) {
            const cardData = {
                student_id: member.student_id,
                name: member.name,
                grade: member.grade,
                status: member.status,
                parent_name: member.parent_name || '',
                contact: member.contact || '',
                academic_year: academicYear,
                include_qr_code: includeQrCode
            };
            idCardData.push(cardData);
        }

        return {
            title: `Member ID Cards - ${academicYear}`,
            data: idCardData,
            cards_per_page: cardsPerPage,
            include_qr_code: includeQrCode,
            academic_year: academicYear,
            summary: {
                total_cards: idCardData.length,
                cards_per_page: cardsPerPage,
                estimated_pages: Math.ceil(idCardData.length / cardsPerPage),
                filters: {
                    status: statusFilter,
                    grade: gradeFilter,
                    academic_year: academicYear
                }
            }
        };
    }
    
}


async function createIdCardPDF(reportData) {
    return new Promise(async (resolve, reject) => {
        try {
            const doc = new PDFDocument({ 
                size: 'LETTER',
                margin: 36 // 0.5 inch margins
            });
            const buffers = [];

            doc.on('data', buffer => buffers.push(buffer));
            doc.on('end', () => {
                const pdfBuffer = Buffer.concat(buffers);
                resolve(pdfBuffer);
            });
            doc.on('error', reject);

            const cardsPerPage = reportData.cards_per_page || 10;
            const cardsData = reportData.data;
            const includeQrCode = reportData.include_qr_code !== false;
            const academicYear = reportData.academic_year || '2024-2025';

            // Calculate card dimensions
            let cardWidth, cardHeight, cols, rows;
            if (cardsPerPage === 10) {
                // 2 columns x 5 rows = 10 cards per page
                cardWidth = 243; // ~3.38 inches at 72 DPI
                cardHeight = 153; // ~2.13 inches at 72 DPI
                cols = 2;
                rows = 5;
            } else { // 8 cards per page
                cardWidth = 252; // ~3.5 inches
                cardHeight = 162; // ~2.25 inches
                cols = 2;
                rows = 4;
            }

            const cardSpacing = 10;

            // Process cards in batches per page
            for (let pageStart = 0; pageStart < cardsData.length; pageStart += cardsPerPage) {
                if (pageStart > 0) {
                    doc.addPage();
                }

                const pageCards = cardsData.slice(pageStart, pageStart + cardsPerPage);

                // Draw cards for this page
                for (let i = 0; i < pageCards.length; i++) {
                    const cardData = pageCards[i];
                    const row = Math.floor(i / cols);
                    const col = i % cols;

                    const x = 36 + col * (cardWidth + cardSpacing);
                    const y = 36 + row * (cardHeight + cardSpacing);

                    await drawSingleIdCard(doc, cardData, x, y, cardWidth, cardHeight, includeQrCode, academicYear);
                }
            }

            doc.end();
        } catch (error) {
            reject(error);
        }
    });
}

// Function to draw a single ID card
async function drawSingleIdCard(doc, memberData, x, y, width, height, includeQrCode, academicYear) {
    // Save the current state
    doc.save();

    // Draw card border
    doc.rect(x, y, width, height)
       .strokeColor('#cccccc')
       .lineWidth(1)
       .stroke();

    // Card background
    doc.rect(x + 1, y + 1, width - 2, height - 2)
       .fillColor('#ffffff')
       .fill();

    // Reset to black for text
    doc.fillColor('#000000');

    // Header - Organization name
    doc.fontSize(12)
       .fillColor('#1e3a8a') // Navy blue
       .font('Helvetica-Bold')
       .text('Chinmaya Mission Columbus', x + 10, y + 8, {
           width: width - 20,
           align: 'center'
       });

    // Bala Vihar subtitle
    doc.fontSize(10)
       .fillColor('#1e40af')
       .font('Helvetica')
       .text('Bala Vihar', x + 10, y + 22, {
           width: width - 20,
           align: 'center'
       });

    // Member name
    doc.fontSize(11)
       .fillColor('#000000')
       .font('Helvetica-Bold')
       .text(memberData.name, x + 10, y + 45, {
           width: includeQrCode ? width - 80 : width - 20,
           align: 'left'
       });

    // Member details
    doc.fontSize(8)
       .fillColor('#374151')
       .font('Helvetica-Bold')
       .text(`ID: ${memberData.student_id}`, x + 10, y + 62);

    doc.text(`Grade: ${memberData.grade}`, x + 10, y + 75);
    doc.text(`Year: ${academicYear}`, x + 10, y + 88);

    if (memberData.parent_name) {
        doc.fontSize(7)
           .fillColor('#6b7280')
           .text(`Parent: ${memberData.parent_name.substring(0, 20)}`, x + 10, y + 105);
    }

    // QR Code
    if (includeQrCode) {
        try {
            const qrData = `${memberData.student_id}|${memberData.name}|${academicYear}|CMC`;
            
            // Generate QR code as data URL
            const qrCodeDataURL = await QRCode.toDataURL(qrData, {
                width: 60,
                margin: 1,
                color: {
                    dark: '#000000',
                    light: '#ffffff'
                }
            });

            // Convert data URL to buffer
            const base64Data = qrCodeDataURL.replace(/^data:image\/png;base64,/, '');
            const qrBuffer = Buffer.from(base64Data, 'base64');

            // Add QR code to PDF
            doc.image(qrBuffer, x + width - 70, y + 45, {
                width: 60,
                height: 60
            });

        } catch (qrError) {
            console.error('QR Code generation error:', qrError);
            // Fallback: draw a placeholder rectangle
            doc.rect(x + width - 70, y + 45, 60, 60)
               .strokeColor('#cccccc')
               .stroke();
            
            doc.fontSize(8)
               .fillColor('#666666')
               .text('QR', x + width - 45, y + 70, {
                   width: 20,
                   align: 'center'
               });
        }
    }

    // Footer
    doc.fontSize(6)
       .fillColor('#9ca3af')
       .font('Helvetica')
       .text(`Valid for ${academicYear} year only`, x + 10, y + height - 15, {
           width: width - 20,
           align: 'center'
       });

    // Restore the state
    doc.restore();
}

// PDF Report Generator
function createPDFReport(reportData) {
    return new Promise((resolve, reject) => {
        try {
            const doc = new PDFDocument({ margin: 50, size: 'A4' });
            const buffers = [];

            doc.on('data', buffer => buffers.push(buffer));
            doc.on('end', () => {
                const pdfBuffer = Buffer.concat(buffers);
                resolve(pdfBuffer);
            });
            doc.on('error', reject);

            // Header
            doc.fontSize(20).text('CMC Bala Vihar', { align: 'center' });
            doc.fontSize(16).text(reportData.title, { align: 'center' });
            doc.moveDown(1);

            // Summary section
            if (reportData.summary) {
                doc.fontSize(14).text('Summary', { underline: true });
                doc.moveDown(0.5);

                for (const [key, value] of Object.entries(reportData.summary)) {
                    if (typeof value === 'object' && value !== null) {
                        doc.fontSize(12).text(`${key.replace(/_/g, ' ').toUpperCase()}:`, { continued: false });
                        for (const [subKey, subValue] of Object.entries(value)) {
                            doc.fontSize(10).text(`  â€¢ ${subKey.replace(/_/g, ' ')}: ${subValue}`);
                        }
                    } else {
                        doc.fontSize(12).text(`${key.replace(/_/g, ' ').toUpperCase()}: ${value}`);
                    }
                }
                doc.moveDown(1);
            }

            // Data table
            if (reportData.data && reportData.data.length > 0) {
                doc.fontSize(14).text('Detailed Data', { underline: true });
                doc.moveDown(0.5);

                const headers = Object.keys(reportData.data[0]);
                const pageWidth = 500;
                const columnWidth = Math.min(pageWidth / headers.length, 100);
                const tableTop = doc.y;
                const itemHeight = 20;
                let currentY = tableTop;

                // Draw headers
                doc.fontSize(10).font('Helvetica-Bold');
                headers.forEach((header, i) => {
                    doc.text(
                        header.replace(/_/g, ' ').toUpperCase(), 
                        50 + (i * columnWidth), 
                        currentY, 
                        { width: columnWidth - 5, align: 'left' }
                    );
                });

                currentY += itemHeight;
                doc.moveTo(50, currentY).lineTo(50 + pageWidth, currentY).stroke();
                currentY += 5;

                // Draw data rows
                doc.font('Helvetica');
                reportData.data.forEach((row, index) => {
                    if (currentY > 700) { // Check if we need a new page
                        doc.addPage();
                        currentY = 50;
                        
                        // Redraw headers on new page
                        doc.fontSize(10).font('Helvetica-Bold');
                        headers.forEach((header, i) => {
                            doc.text(
                                header.replace(/_/g, ' ').toUpperCase(), 
                                50 + (i * columnWidth), 
                                currentY, 
                                { width: columnWidth - 5, align: 'left' }
                            );
                        });
                        currentY += itemHeight;
                        doc.moveTo(50, currentY).lineTo(50 + pageWidth, currentY).stroke();
                        currentY += 5;
                        doc.font('Helvetica');
                    }

                    headers.forEach((header, i) => {
                        const value = row[header] || '';
                        doc.fontSize(9).text(
                            String(value), 
                            50 + (i * columnWidth), 
                            currentY, 
                            { width: columnWidth - 5, align: 'left' }
                        );
                    });

                    currentY += itemHeight;
                    
                    // Draw line after every 5 rows for readability
                    if ((index + 1) % 5 === 0) {
                        doc.moveTo(50, currentY).lineTo(50 + pageWidth, currentY).stroke();
                        currentY += 2;
                    }
                });
            }

            // Footer
            const pages = doc.bufferedPageRange();
            for (let i = 0; i < pages.count; i++) {
                doc.switchToPage(i);
                doc.fontSize(8).text(
                    `Generated on ${moment().format('YYYY-MM-DD HH:mm:ss')} | Page ${i + 1} of ${pages.count}`,
                    50,
                    doc.page.height - 50,
                    { align: 'center' }
                );
            }

            doc.end();
        } catch (error) {
            reject(error);
        }
    });
}

// Excel Report Generator
async function createExcelReport(reportData) {
    const workbook = new ExcelJS.Workbook();
    
    workbook.creator = 'CMC Bala Vihar';
    workbook.lastModifiedBy = 'CMC Bala Vihar';
    workbook.created = new Date();
    workbook.modified = new Date();

    // Create main data worksheet
    if (reportData.data && reportData.data.length > 0) {
        const worksheet = workbook.addWorksheet('Data');
        
        // Add title
        worksheet.mergeCells('A1:' + String.fromCharCode(64 + Object.keys(reportData.data[0]).length) + '1');
        const titleCell = worksheet.getCell('A1');
        titleCell.value = reportData.title;
        titleCell.font = { bold: true, size: 16 };
        titleCell.alignment = { horizontal: 'center' };
        
        // Add headers
        const headers = Object.keys(reportData.data[0]);
        worksheet.addRow([]); // Empty row
        const headerRow = worksheet.addRow(headers.map(h => h.replace(/_/g, ' ').toUpperCase()));
        
        // Style headers
        headerRow.font = { bold: true };
        headerRow.fill = {
            type: 'pattern',
            pattern: 'solid',
            fgColor: { argb: 'FFE0E0E0' }
        };
        headerRow.border = {
            top: { style: 'thin' },
            left: { style: 'thin' },
            bottom: { style: 'thin' },
            right: { style: 'thin' }
        };
        
        // Add data rows
        reportData.data.forEach(row => {
            const rowData = headers.map(header => row[header] || '');
            const dataRow = worksheet.addRow(rowData);
            
            // Add borders to data rows
            dataRow.border = {
                top: { style: 'thin' },
                left: { style: 'thin' },
                bottom: { style: 'thin' },
                right: { style: 'thin' }
            };
        });
        
        // Auto-fit columns
        worksheet.columns.forEach((column, index) => {
            let maxLength = 10;
            column.eachCell({ includeEmpty: true }, (cell) => {
                const cellLength = cell.value ? cell.value.toString().length : 0;
                maxLength = Math.max(maxLength, cellLength);
            });
            column.width = Math.min(maxLength + 2, 30);
        });
    }
    
    // Create summary worksheet
    if (reportData.summary) {
        const summarySheet = workbook.addWorksheet('Summary');
        
        // Add title
        summarySheet.mergeCells('A1:B1');
        const titleCell = summarySheet.getCell('A1');
        titleCell.value = 'Report Summary';
        titleCell.font = { bold: true, size: 16 };
        titleCell.alignment = { horizontal: 'center' };
        
        summarySheet.addRow([]); // Empty row
        const headerRow = summarySheet.addRow(['Metric', 'Value']);
        headerRow.font = { bold: true };
        headerRow.fill = {
            type: 'pattern',
            pattern: 'solid',
            fgColor: { argb: 'FFE0E0E0' }
        };
        
        for (const [key, value] of Object.entries(reportData.summary)) {
            if (typeof value === 'object' && value !== null) {
                for (const [subKey, subValue] of Object.entries(value)) {
                    summarySheet.addRow([
                        `${key.replace(/_/g, ' ')} - ${subKey.replace(/_/g, ' ')}`,
                        String(subValue)
                    ]);
                }
            } else {
                summarySheet.addRow([
                    key.replace(/_/g, ' ').toUpperCase(),
                    String(value)
                ]);
            }
        }
        
        // Auto-fit columns
        summarySheet.columns.forEach(column => {
            let maxLength = 10;
            column.eachCell({ includeEmpty: true }, (cell) => {
                const cellLength = cell.value ? cell.value.toString().length : 0;
                maxLength = Math.max(maxLength, cellLength);
            });
            column.width = Math.min(maxLength + 2, 40);
        });
    }
    
    return await workbook.xlsx.writeBuffer();
}


// Get all reports
router.get('/', requireAuth, async (req, res) => {
    try {
        const reportsCollection = req.db.collection('reports');
        const category = req.query.category;
        const activeOnly = req.query.active_only !== 'false';
        
        const query = {};
        if (activeOnly) {
            query.is_active = true;
        }
        if (category && category !== 'All') {
            query.category = category;
        }
        
        const reports = await reportsCollection
            .find(query, { projection: { _id: 0 } })
            .sort({ category: 1, title: 1 })
            .toArray();
            
        res.json(reports);
    } catch (error) {
        console.error('Error fetching reports:', error);
        res.status(500).json({ error: error.message });
    }
});

// Get report categories
router.get('/categories', requireAuth, async (req, res) => {
    try {
        const reportsCollection = req.db.collection('reports');
        const categories = await reportsCollection.distinct('category', { is_active: true });
        res.json(categories);
    } catch (error) {
        console.error('Error fetching categories:', error);
        res.status(500).json({ error: error.message });
    }
});

// Get report details - MOVED AFTER /generated to prevent route conflicts
router.get('/:report_id', requireAuth, async (req, res) => {
    console.log(`Fetching details for report: ${req.params.report_id}`);
    try {
        const reportsCollection = req.db.collection('reports');
        const report = await reportsCollection.findOne(
            { report_id: req.params.report_id },
            { projection: { _id: 0 } }
        );
        
        if (!report) {
            return res.status(404).json({ error: "Report not found" });
        }
        
        res.json(report);
    } catch (error) {
        console.error('Error fetching report details:', error);
        res.status(500).json({ error: error.message });
    }
});

router.post('/reports/generate', requireAuth, async (req, res) => {
    try {
        const { report_type, parameters = {} } = req.body;
        
        if (!report_type) {
            return res.status(400).json({ error: 'Report type is required' });
        }
        
        const generator = new ReportGenerator(req.db);
        let reportData;
        
        switch (report_type) {
            case 'attendance_summary':
                if (!parameters.start_date || !parameters.end_date) {
                    return res.status(400).json({ 
                        error: 'start_date and end_date are required for attendance summary' 
                    });
                }
                reportData = await generator.generateAttendanceSummary(parameters);
                break;
                
            case 'student_roster':
                reportData = await generator.generateStudentRoster(parameters);
                break;
                
            case 'daily_attendance':
                if (!parameters.date) {
                    return res.status(400).json({ 
                        error: 'date is required for daily attendance report' 
                    });
                }
                reportData = await generator.generateDailyAttendance(parameters);
                break;
                
            default:
                return res.status(400).json({ error: 'Invalid report type' });
        }
        
        res.json({
            success: true,
            report: reportData
        });
        
    } catch (error) {
        console.error('Error generating report:', error);
        res.status(500).json({ error: 'Failed to change password' });
    }
});


// Generate report
router.post('/:report_id/generate', requireAuth, async (req, res) => {
    try {
        const reportsCollection = req.db.collection('reports');
        const generatedReportsCollection = req.db.collection('generated_reports');
        
        // Get report details
        const report = await reportsCollection.findOne({ report_id: req.params.report_id });
        if (!report) {
            return res.status(404).json({ error: "Report not found" });
        }
        
        if (!report.is_active) {
            return res.status(400).json({ error: "Report is not active" });
        }
        
        // Get parameters from request
        const { parameters = {}, output_format = 'PDF' } = req.body;
        
        // Validate required parameters
        for (const param of report.parameters || []) {
            if (param.required && !parameters[param.name]) {
                return res.status(400).json({
                    error: `Required parameter '${param.label}' is missing`
                });
            }
        }
        
        // Generate report data based on report type
        const reportGenerator = new ReportGenerator(req.db);
        let reportData;
        
        switch (req.params.report_id) {
            case 'attendance_summary':
                reportData = await reportGenerator.generateAttendanceSummary(parameters);
                break;
            case 'student_roster':
                reportData = await reportGenerator.generateStudentRoster(parameters);
                break;
            case 'daily_attendance':
                reportData = await reportGenerator.generateDailyAttendance(parameters);
                break;
            case 'enrollment_statistics':
                reportData = await reportGenerator.generateEnrollmentStatistics(parameters);
                break;
             case 'member_id_cards':
                reportData = await reportGenerator.generateMemberIdCards(parameters);
                break;
            default:
                return res.status(400).json({ 
                    error: "Report generation not implemented for this report type" 
                });
        }
        
        // Generate file
        let fileBuffer;
        let fileExtension;
        let contentType;
        
        if (output_format === 'PDF') {
            // Use specialized ID card PDF generator for ID card reports
            if (req.params.report_id === 'member_id_cards') {
                fileBuffer = await createIdCardPDF(reportData);
            } else {
                fileBuffer = await createPDFReport(reportData);
            }
            fileExtension = 'pdf';
            contentType = 'application/pdf';
        } else if (output_format === 'Excel') {
            fileBuffer = await createExcelReport(reportData);
            fileExtension = 'xlsx';
            contentType = 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet';
        } else {
            return res.status(400).json({ error: "Unsupported output format" });
        }
        
        // Save file to temporary directory
        const fileId = uuidv4();
        const filename = `${req.params.report_id}_${moment().format('YYYYMMDD_HHmmss')}.${fileExtension}`;
        const tempDir = process.env.TEMP_DIR || require('os').tmpdir();
        const filePath = path.join(tempDir, filename);
        console.log(`Saving report to ${filePath}`);
        await fs.writeFile(filePath, fileBuffer);
        
        // Store metadata in database
        const reportMetadata = {
            file_id: fileId,
            report_id: req.params.report_id,
            filename: filename,
            file_path: filePath,
            parameters: parameters,
            output_format: output_format,
            generated_at: new Date(),
            //generated_by: 'admin', 
            generated_by: req.user.username || req.user,
            //req.session.user.username || req.session.user,
            expires_at: moment().add(7, 'days').toDate(), // Files expire after 7 days
            file_size: fileBuffer.length,
            download_count: 0
        };
        
        await generatedReportsCollection.insertOne(reportMetadata);
        
        const response = {
            status: "success",
            message: `Report '${report.title}' generated successfully`,
            file_id: fileId,
            filename: filename,
            download_url: `/api/reports/download/${fileId}`,
            generated_at: new Date().toISOString(),
            expires_at: reportMetadata.expires_at.toISOString(),
            file_size: reportMetadata.file_size
        };
        
        res.json(response);
        
    } catch (error) {
        console.error('Error generating report:', error);
        res.status(500).json({ error: error.message });
    }
});

// Download report
router.get('/download/:file_id', requireAuth, async (req, res) => {
    try {
        const generatedReportsCollection = req.db.collection('generated_reports');
        
        // Find the file metadata
        const fileMetadata = await generatedReportsCollection.findOne({ 
            file_id: req.params.file_id 
        });
        
        if (!fileMetadata) {
            return res.status(404).json({ error: "File not found" });
        }
        
        // Check if file has expired
        if (new Date() > fileMetadata.expires_at) {
            return res.status(410).json({ error: "File has expired" });
        }
        
        // Check if file exists
        try {
            await fs.access(fileMetadata.file_path);
        } catch {
            return res.status(404).json({ error: "File no longer available" });
        }
        
        // Update download count
        await generatedReportsCollection.updateOne(
            { file_id: req.params.file_id },
            { $inc: { download_count: 1 } }
        );
        
        // Determine content type
        const contentType = fileMetadata.filename.endsWith('.pdf') ? 
            'application/pdf' : 
            'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet';
        
        // Send file
        res.setHeader('Content-Type', contentType);
        res.setHeader('Content-Disposition', `attachment; filename="${fileMetadata.filename}"`);
        res.setHeader('Content-Length', fileMetadata.file_size);
        
        const fileBuffer = await fs.readFile(fileMetadata.file_path);
        res.send(fileBuffer);
        
    } catch (error) {
        console.error('Error downloading report:', error);
        res.status(500).json({ error: error.message });
    }
});


// Preview report data (without generating file)
router.post('/:report_id/preview', requireAuth, async (req, res) => {
    try {
        const reportsCollection = req.db.collection('reports');
        
        // Get report details
        const report = await reportsCollection.findOne({ report_id: req.params.report_id });
        if (!report) {
            return res.status(404).json({ error: "Report not found" });
        }
        
        if (!report.is_active) {
            return res.status(400).json({ error: "Report is not active" });
        }
        
        // Get parameters from request
        const { parameters = {} } = req.body;
        
        // Validate required parameters
        for (const param of report.parameters || []) {
            if (param.required && !parameters[param.name]) {
                return res.status(400).json({
                    error: `Required parameter '${param.label}' is missing`
                });
            }
        }
        
        // Generate report data
        const reportGenerator = new ReportGenerator(req.db);
        let reportData;
        
        switch (req.params.report_id) {
            case 'attendance_summary':
                reportData = await reportGenerator.generateAttendanceSummary(parameters);
                break;
            case 'student_roster':
                reportData = await reportGenerator.generateStudentRoster(parameters);
                break;
            case 'daily_attendance':
                reportData = await reportGenerator.generateDailyAttendance(parameters);
                break;
            case 'enrollment_statistics':
                reportData = await reportGenerator.generateEnrollmentStatistics(parameters);
                break;
            case 'member_id_cards':
                reportData = await reportGenerator.generateMemberIdCards(parameters);
                break;
            default:
                return res.status(400).json({ 
                    error: "Report preview not implemented for this report type" 
                });
        }
        
        // Return preview data (limit to first 10 rows for performance)
        const previewData = {
            ...reportData,
            data: reportData.data ? reportData.data.slice(0, 10) : [],
            preview_note: reportData.data && reportData.data.length > 10 ? 
                `Showing first 10 of ${reportData.data.length} records` : null
        };
        
        res.json(previewData);
        
    } catch (error) {
        console.error('Error generating report preview:', error);
        res.status(500).json({ error: error.message });
    }
});

// Clean up expired files (can be called periodically or as admin function)
router.delete('/cleanup', requireAuth, async (req, res) => {
    try {
        const generatedReportsCollection = req.db.collection('generated_reports');
        
        // Find expired files
        const expiredFiles = await generatedReportsCollection
            .find({ expires_at: { $lt: new Date() } })
            .toArray();
        
        let deletedFiles = 0;
        let errors = [];
        
        for (const file of expiredFiles) {
            try {
                // Delete physical file
                await fs.unlink(file.file_path);
                deletedFiles++;
            } catch (error) {
                errors.push(`Failed to delete ${file.filename}: ${error.message}`);
            }
        }
        
        // Remove metadata from database
        const result = await generatedReportsCollection.deleteMany({
            expires_at: { $lt: new Date() }
        });
        
        res.json({
            message: 'Cleanup completed',
            deleted_files: deletedFiles,
            removed_records: result.deletedCount,
            errors: errors
        });
        
    } catch (error) {
        console.error('Error during cleanup:', error);
        res.status(500).json({ error: error.message });
    }
});

// Helper function to estimate record count
async function estimateRecordCount(db, reportId, parameters) {
    try {
        switch (reportId) {
            case 'attendance_summary':
                if (parameters.start_date && parameters.end_date) {
                    const startDate = moment(parameters.start_date).startOf('day').toDate();
                    const endDate = moment(parameters.end_date).endOf('day').toDate();
                    const attendanceCollection = db.collection('attendance');
                    
                    return await attendanceCollection.countDocuments({
                        timestamp: { $gte: startDate, $lte: endDate }
                    });
                }
                break;
                
            case 'student_roster':
                const memberCollection = db.collection('member');
                const query = {};
                
                if (parameters.status && parameters.status !== 'All') {
                    query.status = parameters.status;
                }
                if (parameters.grade && parameters.grade !== 'All') {
                    query.grade = parameters.grade;
                }
                
                return await memberCollection.countDocuments(query);
                
            case 'daily_attendance':
                const allStudentsCollection = db.collection('member');
                return await allStudentsCollection.countDocuments({ status: 'Active' });
                
            default:
                return null;
        }
    } catch (error) {
        console.error('Error estimating record count:', error);
        return null;
    }
}

module.exports = router;