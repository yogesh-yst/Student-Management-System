// routes/reports.js - Fixed Reports handling routes
const express = require('express');
const router = express.Router();
const moment = require('moment');
const { v4: uuidv4 } = require('uuid');
const path = require('path');
const fs = require('fs').promises;
const PDFDocument = require('pdfkit');
const ExcelJS = require('exceljs');

// Authentication middleware
const requireAuth = (req, res, next) => {
    if (!req.session || !req.session.user) {
        return res.status(401).json({ error: 'Unauthorized - Please login' });
    }
    next();
};

// IMPORTANT: Move the /generated route BEFORE the /:report_id route to prevent conflicts
// Get generated reports for current user - MOVED UP
router.get('/generated', requireAuth, async (req, res) => {
    console.log('Fetching generated reports for user:', req.session.user.username || req.session.user);
    try {
        const generatedReportsCollection = req.db.collection('generated_reports');
        const user = req.session.user.username || req.session.user;
        
        // Get reports generated by current user that haven't expired
        const generatedReports = await generatedReportsCollection
            .find(
                {
                    generated_by: user,
                    expires_at: { $gte: new Date() }
                },
                { projection: { _id: 0 } }
            )
            .sort({ generated_at: -1 })
            .toArray();
        
        console.log(`Found ${generatedReports.length} generated reports for user ${user}`);
        res.json(generatedReports);
        
    } catch (error) {
        console.error('Error fetching generated reports:', error);
        res.status(500).json({ error: error.message });
    }
});

// Report generation classes
class ReportGenerator {
    constructor(db) {
        this.db = db;
        this.attendanceCollection = db.collection('attendance');
        this.memberCollection = db.collection('member');
        this.generatedReportsCollection = db.collection('generated_reports');
    }

    async generateAttendanceSummary(parameters) {
        const startDate = moment(parameters.start_date).startOf('day').toDate();
        const endDate = moment(parameters.end_date).endOf('day').toDate();
        const gradeFilter = parameters.grade;

        // Query attendance data
        const query = {
            timestamp: {
                $gte: startDate,
                $lte: endDate
            }
        };

        const attendanceRecords = await this.attendanceCollection.find(query).toArray();

        // Get student details
        const studentIds = attendanceRecords.map(record => record.student_id);
        const membersQuery = { student_id: { $in: studentIds } };
        
        if (gradeFilter && gradeFilter !== 'All') {
            membersQuery.grade = gradeFilter;
        }

        const members = await this.memberCollection.find(membersQuery).toArray();
        const memberDict = {};
        members.forEach(member => {
            memberDict[member.student_id] = member;
        });

        // Process data
        const attendanceData = [];
        for (const record of attendanceRecords) {
            const studentId = record.student_id;
            if (memberDict[studentId]) {
                const member = memberDict[studentId];
                attendanceData.push({
                    student_id: studentId,
                    name: member.name,
                    grade: member.grade,
                    date: moment(record.timestamp).format('YYYY-MM-DD'),
                    time: moment(record.timestamp).format('HH:mm:ss')
                });
            }
        }

        return {
            title: `Attendance Summary (${moment(startDate).format('YYYY-MM-DD')} to ${moment(endDate).format('YYYY-MM-DD')})`,
            data: attendanceData,
            summary: {
                total_records: attendanceData.length,
                unique_students: new Set(attendanceData.map(r => r.student_id)).size,
                date_range: `${moment(startDate).format('YYYY-MM-DD')} to ${moment(endDate).format('YYYY-MM-DD')}`
            }
        };
    }

    async generateStudentRoster(parameters) {
        const statusFilter = parameters.status || 'All';
        const gradeFilter = parameters.grade || 'All';
        const includeContact = parameters.include_contact !== false;

        // Build query
        const query = {};
        if (statusFilter !== 'All') {
            query.status = statusFilter;
        }
        if (gradeFilter !== 'All') {
            query.grade = gradeFilter;
        }

        // Get student data
        const members = await this.memberCollection
            .find(query)
            .sort({ grade: 1, name: 1 })
            .toArray();

        // Process data
        const rosterData = [];
        for (const member of members) {
            const studentData = {
                student_id: member.student_id,
                name: member.name,
                grade: member.grade,
                status: member.status
            };

            if (includeContact) {
                studentData.parent_name = member.parent_name || '';
                studentData.contact = member.contact || '';
                studentData.email = member.email || '';
            }

            rosterData.push(studentData);
        }

        return {
            title: 'Student Roster Report',
            data: rosterData,
            summary: {
                total_students: rosterData.length,
                filters: {
                    status: statusFilter,
                    grade: gradeFilter,
                    include_contact: includeContact
                }
            }
        };
    }

    async generateDailyAttendance(parameters) {
        const targetDate = moment(parameters.date).startOf('day').toDate();
        const startOfDay = moment(targetDate).startOf('day').toDate();
        const endOfDay = moment(targetDate).endOf('day').toDate();

        // Query attendance for the day
        const attendanceRecords = await this.attendanceCollection
            .find({
                timestamp: { $gte: startOfDay, $lte: endOfDay }
            })
            .sort({ timestamp: 1 })
            .toArray();

        // Get all active students for comparison
        const allStudents = await this.memberCollection
            .find(
                { status: "Active" },
                { projection: { student_id: 1, name: 1, grade: 1 } }
            )
            .sort({ grade: 1, name: 1 })
            .toArray();

        // Create attendance data
        const presentStudents = {};
        attendanceRecords.forEach(record => {
            presentStudents[record.student_id] = record;
        });

        const dailyData = [];
        for (const student of allStudents) {
            const studentId = student.student_id;
            const attendanceRecord = presentStudents[studentId];

            dailyData.push({
                student_id: studentId,
                name: student.name,
                grade: student.grade,
                status: attendanceRecord ? 'Present' : 'Absent',
                check_in_time: attendanceRecord ? 
                    moment(attendanceRecord.timestamp).format('HH:mm:ss') : ''
            });
        }

        const attendanceRate = allStudents.length > 0 ? 
            (attendanceRecords.length / allStudents.length * 100).toFixed(1) : '0';

        return {
            title: `Daily Attendance Report - ${moment(targetDate).format('YYYY-MM-DD')}`,
            data: dailyData,
            summary: {
                date: moment(targetDate).format('YYYY-MM-DD'),
                total_students: allStudents.length,
                present: attendanceRecords.length,
                absent: allStudents.length - attendanceRecords.length,
                attendance_rate: `${attendanceRate}%`
            }
        };
    }

    async generateEnrollmentStatistics(parameters) {
        const academicYear = parameters.academic_year || '2024-2025';
        
        // Get enrollment by grade
        const enrollmentByGrade = await this.memberCollection.aggregate([
            { $match: { status: { $in: ['Active', 'Inactive'] } } },
            { 
                $group: {
                    _id: '$grade',
                    total: { $sum: 1 },
                    active: { $sum: { $cond: [{ $eq: ['$status', 'Active'] }, 1, 0] } },
                    inactive: { $sum: { $cond: [{ $eq: ['$status', 'Inactive'] }, 1, 0] } }
                }
            },
            { $sort: { _id: 1 } }
        ]).toArray();

        // Get enrollment trends by month (registration dates)
        const enrollmentTrends = await this.memberCollection.aggregate([
            { $match: { created_at: { $exists: true } } },
            {
                $group: {
                    _id: {
                        year: { $year: '$created_at' },
                        month: { $month: '$created_at' }
                    },
                    count: { $sum: 1 }
                }
            },
            { $sort: { '_id.year': 1, '_id.month': 1 } },
            { $limit: 12 }
        ]).toArray();

        // Get status distribution
        const statusDistribution = await this.memberCollection.aggregate([
            {
                $group: {
                    _id: '$status',
                    count: { $sum: 1 }
                }
            }
        ]).toArray();

        // Prepare summary data
        const summaryData = [];
        
        // Add grade statistics
        enrollmentByGrade.forEach(grade => {
            summaryData.push({
                category: 'Grade',
                subcategory: grade._id,
                total: grade.total,
                active: grade.active,
                inactive: grade.inactive
            });
        });

        // Add monthly trends
        enrollmentTrends.forEach(trend => {
            summaryData.push({
                category: 'Monthly Registration',
                subcategory: `${trend._id.year}-${String(trend._id.month).padStart(2, '0')}`,
                total: trend.count,
                active: '',
                inactive: ''
            });
        });

        // Add status distribution
        statusDistribution.forEach(status => {
            summaryData.push({
                category: 'Status',
                subcategory: status._id,
                total: status.count,
                active: '',
                inactive: ''
            });
        });

        return {
            title: `Enrollment Statistics - ${academicYear}`,
            data: summaryData,
            summary: {
                academic_year: academicYear,
                total_enrolled: enrollmentByGrade.reduce((sum, grade) => sum + grade.total, 0),
                total_active: enrollmentByGrade.reduce((sum, grade) => sum + grade.active, 0),
                total_grades: enrollmentByGrade.length
            }
        };
    }
}

// PDF Report Generator
function createPDFReport(reportData) {
    return new Promise((resolve, reject) => {
        try {
            const doc = new PDFDocument({ margin: 50, size: 'A4' });
            const buffers = [];

            doc.on('data', buffer => buffers.push(buffer));
            doc.on('end', () => {
                const pdfBuffer = Buffer.concat(buffers);
                resolve(pdfBuffer);
            });
            doc.on('error', reject);

            // Header
            doc.fontSize(20).text('CMC Bala Vihar', { align: 'center' });
            doc.fontSize(16).text(reportData.title, { align: 'center' });
            doc.moveDown(1);

            // Summary section
            if (reportData.summary) {
                doc.fontSize(14).text('Summary', { underline: true });
                doc.moveDown(0.5);

                for (const [key, value] of Object.entries(reportData.summary)) {
                    if (typeof value === 'object' && value !== null) {
                        doc.fontSize(12).text(`${key.replace(/_/g, ' ').toUpperCase()}:`, { continued: false });
                        for (const [subKey, subValue] of Object.entries(value)) {
                            doc.fontSize(10).text(`  • ${subKey.replace(/_/g, ' ')}: ${subValue}`);
                        }
                    } else {
                        doc.fontSize(12).text(`${key.replace(/_/g, ' ').toUpperCase()}: ${value}`);
                    }
                }
                doc.moveDown(1);
            }

            // Data table
            if (reportData.data && reportData.data.length > 0) {
                doc.fontSize(14).text('Detailed Data', { underline: true });
                doc.moveDown(0.5);

                const headers = Object.keys(reportData.data[0]);
                const pageWidth = 500;
                const columnWidth = Math.min(pageWidth / headers.length, 100);
                const tableTop = doc.y;
                const itemHeight = 20;
                let currentY = tableTop;

                // Draw headers
                doc.fontSize(10).font('Helvetica-Bold');
                headers.forEach((header, i) => {
                    doc.text(
                        header.replace(/_/g, ' ').toUpperCase(), 
                        50 + (i * columnWidth), 
                        currentY, 
                        { width: columnWidth - 5, align: 'left' }
                    );
                });

                currentY += itemHeight;
                doc.moveTo(50, currentY).lineTo(50 + pageWidth, currentY).stroke();
                currentY += 5;

                // Draw data rows
                doc.font('Helvetica');
                reportData.data.forEach((row, index) => {
                    if (currentY > 700) { // Check if we need a new page
                        doc.addPage();
                        currentY = 50;
                        
                        // Redraw headers on new page
                        doc.fontSize(10).font('Helvetica-Bold');
                        headers.forEach((header, i) => {
                            doc.text(
                                header.replace(/_/g, ' ').toUpperCase(), 
                                50 + (i * columnWidth), 
                                currentY, 
                                { width: columnWidth - 5, align: 'left' }
                            );
                        });
                        currentY += itemHeight;
                        doc.moveTo(50, currentY).lineTo(50 + pageWidth, currentY).stroke();
                        currentY += 5;
                        doc.font('Helvetica');
                    }

                    headers.forEach((header, i) => {
                        const value = row[header] || '';
                        doc.fontSize(9).text(
                            String(value), 
                            50 + (i * columnWidth), 
                            currentY, 
                            { width: columnWidth - 5, align: 'left' }
                        );
                    });

                    currentY += itemHeight;
                    
                    // Draw line after every 5 rows for readability
                    if ((index + 1) % 5 === 0) {
                        doc.moveTo(50, currentY).lineTo(50 + pageWidth, currentY).stroke();
                        currentY += 2;
                    }
                });
            }

            // Footer
            const pages = doc.bufferedPageRange();
            for (let i = 0; i < pages.count; i++) {
                doc.switchToPage(i);
                doc.fontSize(8).text(
                    `Generated on ${moment().format('YYYY-MM-DD HH:mm:ss')} | Page ${i + 1} of ${pages.count}`,
                    50,
                    doc.page.height - 50,
                    { align: 'center' }
                );
            }

            doc.end();
        } catch (error) {
            reject(error);
        }
    });
}

// Excel Report Generator
async function createExcelReport(reportData) {
    const workbook = new ExcelJS.Workbook();
    
    workbook.creator = 'CMC Bala Vihar';
    workbook.lastModifiedBy = 'CMC Bala Vihar';
    workbook.created = new Date();
    workbook.modified = new Date();

    // Create main data worksheet
    if (reportData.data && reportData.data.length > 0) {
        const worksheet = workbook.addWorksheet('Data');
        
        // Add title
        worksheet.mergeCells('A1:' + String.fromCharCode(64 + Object.keys(reportData.data[0]).length) + '1');
        const titleCell = worksheet.getCell('A1');
        titleCell.value = reportData.title;
        titleCell.font = { bold: true, size: 16 };
        titleCell.alignment = { horizontal: 'center' };
        
        // Add headers
        const headers = Object.keys(reportData.data[0]);
        worksheet.addRow([]); // Empty row
        const headerRow = worksheet.addRow(headers.map(h => h.replace(/_/g, ' ').toUpperCase()));
        
        // Style headers
        headerRow.font = { bold: true };
        headerRow.fill = {
            type: 'pattern',
            pattern: 'solid',
            fgColor: { argb: 'FFE0E0E0' }
        };
        headerRow.border = {
            top: { style: 'thin' },
            left: { style: 'thin' },
            bottom: { style: 'thin' },
            right: { style: 'thin' }
        };
        
        // Add data rows
        reportData.data.forEach(row => {
            const rowData = headers.map(header => row[header] || '');
            const dataRow = worksheet.addRow(rowData);
            
            // Add borders to data rows
            dataRow.border = {
                top: { style: 'thin' },
                left: { style: 'thin' },
                bottom: { style: 'thin' },
                right: { style: 'thin' }
            };
        });
        
        // Auto-fit columns
        worksheet.columns.forEach((column, index) => {
            let maxLength = 10;
            column.eachCell({ includeEmpty: true }, (cell) => {
                const cellLength = cell.value ? cell.value.toString().length : 0;
                maxLength = Math.max(maxLength, cellLength);
            });
            column.width = Math.min(maxLength + 2, 30);
        });
    }
    
    // Create summary worksheet
    if (reportData.summary) {
        const summarySheet = workbook.addWorksheet('Summary');
        
        // Add title
        summarySheet.mergeCells('A1:B1');
        const titleCell = summarySheet.getCell('A1');
        titleCell.value = 'Report Summary';
        titleCell.font = { bold: true, size: 16 };
        titleCell.alignment = { horizontal: 'center' };
        
        summarySheet.addRow([]); // Empty row
        const headerRow = summarySheet.addRow(['Metric', 'Value']);
        headerRow.font = { bold: true };
        headerRow.fill = {
            type: 'pattern',
            pattern: 'solid',
            fgColor: { argb: 'FFE0E0E0' }
        };
        
        for (const [key, value] of Object.entries(reportData.summary)) {
            if (typeof value === 'object' && value !== null) {
                for (const [subKey, subValue] of Object.entries(value)) {
                    summarySheet.addRow([
                        `${key.replace(/_/g, ' ')} - ${subKey.replace(/_/g, ' ')}`,
                        String(subValue)
                    ]);
                }
            } else {
                summarySheet.addRow([
                    key.replace(/_/g, ' ').toUpperCase(),
                    String(value)
                ]);
            }
        }
        
        // Auto-fit columns
        summarySheet.columns.forEach(column => {
            let maxLength = 10;
            column.eachCell({ includeEmpty: true }, (cell) => {
                const cellLength = cell.value ? cell.value.toString().length : 0;
                maxLength = Math.max(maxLength, cellLength);
            });
            column.width = Math.min(maxLength + 2, 40);
        });
    }
    
    return await workbook.xlsx.writeBuffer();
}

// Simple test endpoint to verify routes are working
router.get('/test', (req, res) => {
    console.log('Reports test endpoint accessed');
    res.json({ message: 'Reports routes are working!', timestamp: new Date() });
});

// Get all reports
router.get('/', requireAuth, async (req, res) => {
    try {
        const reportsCollection = req.db.collection('reports');
        const category = req.query.category;
        const activeOnly = req.query.active_only !== 'false';
        
        const query = {};
        if (activeOnly) {
            query.is_active = true;
        }
        if (category && category !== 'All') {
            query.category = category;
        }
        
        const reports = await reportsCollection
            .find(query, { projection: { _id: 0 } })
            .sort({ category: 1, title: 1 })
            .toArray();
            
        res.json(reports);
    } catch (error) {
        console.error('Error fetching reports:', error);
        res.status(500).json({ error: error.message });
    }
});

// Get report categories
router.get('/categories', requireAuth, async (req, res) => {
    try {
        const reportsCollection = req.db.collection('reports');
        const categories = await reportsCollection.distinct('category', { is_active: true });
        res.json(categories);
    } catch (error) {
        console.error('Error fetching categories:', error);
        res.status(500).json({ error: error.message });
    }
});

// Get report details - MOVED AFTER /generated to prevent route conflicts
router.get('/:report_id', requireAuth, async (req, res) => {
    console.log(`Fetching details for report: ${req.params.report_id}`);
    try {
        const reportsCollection = req.db.collection('reports');
        const report = await reportsCollection.findOne(
            { report_id: req.params.report_id },
            { projection: { _id: 0 } }
        );
        
        if (!report) {
            return res.status(404).json({ error: "Report not found" });
        }
        
        res.json(report);
    } catch (error) {
        console.error('Error fetching report details:', error);
        res.status(500).json({ error: error.message });
    }
});

// Generate report
router.post('/:report_id/generate', requireAuth, async (req, res) => {
    try {
        const reportsCollection = req.db.collection('reports');
        const generatedReportsCollection = req.db.collection('generated_reports');
        
        // Get report details
        const report = await reportsCollection.findOne({ report_id: req.params.report_id });
        if (!report) {
            return res.status(404).json({ error: "Report not found" });
        }
        
        if (!report.is_active) {
            return res.status(400).json({ error: "Report is not active" });
        }
        
        // Get parameters from request
        const { parameters = {}, output_format = 'PDF' } = req.body;
        
        // Validate required parameters
        for (const param of report.parameters || []) {
            if (param.required && !parameters[param.name]) {
                return res.status(400).json({
                    error: `Required parameter '${param.label}' is missing`
                });
            }
        }
        
        // Generate report data based on report type
        const reportGenerator = new ReportGenerator(req.db);
        let reportData;
        
        switch (req.params.report_id) {
            case 'attendance_summary':
                reportData = await reportGenerator.generateAttendanceSummary(parameters);
                break;
            case 'student_roster':
                reportData = await reportGenerator.generateStudentRoster(parameters);
                break;
            case 'daily_attendance':
                reportData = await reportGenerator.generateDailyAttendance(parameters);
                break;
            case 'enrollment_statistics':
                reportData = await reportGenerator.generateEnrollmentStatistics(parameters);
                break;
            default:
                return res.status(400).json({ 
                    error: "Report generation not implemented for this report type" 
                });
        }
        
        // Generate file
        let fileBuffer;
        let fileExtension;
        let contentType;
        
        if (output_format === 'PDF') {
            fileBuffer = await createPDFReport(reportData);
            fileExtension = 'pdf';
            contentType = 'application/pdf';
        } else if (output_format === 'Excel') {
            fileBuffer = await createExcelReport(reportData);
            fileExtension = 'xlsx';
            contentType = 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet';
        } else {
            return res.status(400).json({ error: "Unsupported output format" });
        }
        
        // Save file to temporary directory
        const fileId = uuidv4();
        const filename = `${req.params.report_id}_${moment().format('YYYYMMDD_HHmmss')}.${fileExtension}`;
        const tempDir = process.env.TEMP_DIR || require('os').tmpdir();
        const filePath = path.join(tempDir, filename);
        console.log(`Saving report to ${filePath}`);
        await fs.writeFile(filePath, fileBuffer);
        
        // Store metadata in database
        const reportMetadata = {
            file_id: fileId,
            report_id: req.params.report_id,
            filename: filename,
            file_path: filePath,
            parameters: parameters,
            output_format: output_format,
            generated_at: new Date(),
            generated_by: req.session.user.username || req.session.user,
            expires_at: moment().add(7, 'days').toDate(), // Files expire after 7 days
            file_size: fileBuffer.length,
            download_count: 0
        };
        
        await generatedReportsCollection.insertOne(reportMetadata);
        
        const response = {
            status: "success",
            message: `Report '${report.title}' generated successfully`,
            file_id: fileId,
            filename: filename,
            download_url: `/api/reports/download/${fileId}`,
            generated_at: new Date().toISOString(),
            expires_at: reportMetadata.expires_at.toISOString(),
            file_size: reportMetadata.file_size
        };
        
        res.json(response);
        
    } catch (error) {
        console.error('Error generating report:', error);
        res.status(500).json({ error: error.message });
    }
});

// Download report
router.get('/download/:file_id', requireAuth, async (req, res) => {
    try {
        const generatedReportsCollection = req.db.collection('generated_reports');
        
        // Find the file metadata
        const fileMetadata = await generatedReportsCollection.findOne({ 
            file_id: req.params.file_id 
        });
        
        if (!fileMetadata) {
            return res.status(404).json({ error: "File not found" });
        }
        
        // Check if file has expired
        if (new Date() > fileMetadata.expires_at) {
            return res.status(410).json({ error: "File has expired" });
        }
        
        // Check if file exists
        try {
            await fs.access(fileMetadata.file_path);
        } catch {
            return res.status(404).json({ error: "File no longer available" });
        }
        
        // Update download count
        await generatedReportsCollection.updateOne(
            { file_id: req.params.file_id },
            { $inc: { download_count: 1 } }
        );
        
        // Determine content type
        const contentType = fileMetadata.filename.endsWith('.pdf') ? 
            'application/pdf' : 
            'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet';
        
        // Send file
        res.setHeader('Content-Type', contentType);
        res.setHeader('Content-Disposition', `attachment; filename="${fileMetadata.filename}"`);
        res.setHeader('Content-Length', fileMetadata.file_size);
        
        const fileBuffer = await fs.readFile(fileMetadata.file_path);
        res.send(fileBuffer);
        
    } catch (error) {
        console.error('Error downloading report:', error);
        res.status(500).json({ error: error.message });
    }
});

// Helper function to estimate record count
async function estimateRecordCount(db, reportId, parameters) {
    try {
        switch (reportId) {
            case 'attendance_summary':
                if (parameters.start_date && parameters.end_date) {
                    const startDate = moment(parameters.start_date).startOf('day').toDate();
                    const endDate = moment(parameters.end_date).endOf('day').toDate();
                    const attendanceCollection = db.collection('attendance');
                    
                    return await attendanceCollection.countDocuments({
                        timestamp: { $gte: startDate, $lte: endDate }
                    });
                }
                break;
                
            case 'student_roster':
                const memberCollection = db.collection('member');
                const query = {};
                
                if (parameters.status && parameters.status !== 'All') {
                    query.status = parameters.status;
                }
                if (parameters.grade && parameters.grade !== 'All') {
                    query.grade = parameters.grade;
                }
                
                return await memberCollection.countDocuments(query);
                
            case 'daily_attendance':
                const allStudentsCollection = db.collection('member');
                return await allStudentsCollection.countDocuments({ status: 'Active' });
                
            default:
                return null;
        }
    } catch (error) {
        console.error('Error estimating record count:', error);
        return null;
    }
}

module.exports = router;